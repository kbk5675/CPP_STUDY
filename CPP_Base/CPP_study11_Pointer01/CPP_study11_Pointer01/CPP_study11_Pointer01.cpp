#include <iostream>
using namespace std;


// 오늘의 주제 : 포인터

//exRPG)
void SetHp(int* hp) {
	*hp = 100;
}

int main()
{
	//exRPG)
	int hp = 10;
	SetHp(&hp);

	// 지금까지 사용한 방식
	// number라는 이름의 4바이트 정수 타입의 바구니를 만든다.
	// number라는 변수 스택 메모리에 할당.
	// number = 1라 함은, number 바구니에 1이라는 숫자를 넣으라는 의미.
	// 따라서 스택 메모리에 있는 특정 주소(number 바구니)에 우리가 원하는 값을 넣은 셈이다.
	// number는 비유하자면 메모리에 이름을 붙인 것(컴파일러가 찰떡같이 알아들어서 알아서 할당해주는거임.)
	
	// 나쁘지않고 편리하지만 단점이 있다.
	// 언제 어디서든 사용불가(다른 함수 사용X, 외부 클래스 사용X)
	// 원본을 수정해야한다.

	int number = 1; //4byte 지역변수

	// 포인터
	// TYPE* 변수이름;
	// - TYPE
	// - *
	// 바구니는 바구니이지만..[주소를 저장하는 바구니입니다!!]
	// 변수 선언할 때 * 등장했다 -> 포인터 = 주소
	//변수앞 &표시 : "주소를 가져와주세요" 라는의미!
	//참고) 포인터라는 바구니는 4바이트 or 8바이트(64비트) 고정크기!!
	

	//EX)
	int* ptr = &number; //4byte 포인터 지역변수 ptr

	cout << ptr << endl;

	// 근데 남의 주소를 뭘하라는 것인가? 목적이 뭔가?
	// 추가 문법 : [주소를 저장하는 바구니]가 가리키는 주소로 가서 무엇인가를 해라!
	// *변수이름 = 값;

	// 포탈을 타고 순간이동 한다고 생각해보자.
	// *이 여러번 등장하니 헷갈리는데, 사용 시점에 따라서 구분해서 기억하자
	// - 변수 선언(주소를 저장하는 바구니!)
	// - 사용할 때(포탈 타고 순간이동)
	
	int value1 = *ptr; //4byte 변수에 주소를 저장하는 ptr바구니를 넣었다.
	*ptr = 2; //ptr이라는 바구니로 이동해서 그 바구니에 2를 넣어라! (바구니 = 주소)

	//타입의 불일치 경우
	__int64* ptr2 = (__int64*)&number; // 강제 타입변환
	*ptr2 = 0xAABBCCDDEEFF;

	return 0;
}